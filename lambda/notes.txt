SYSTEM PATHS

/schema/classes.json
/schema/classes/{class_name}.json
/schema/properties.json
/schema/properties/{property}.json
/schema/datatypes.json
/schema/datatypes/{datatype}.json

/record/{class_name}/{record_id}.json => canonical record
/version/{class_name}/{record_id}/{version_id}.json => list of record fields updated for each version

/vector/{class_name}/{field_name}.json => list of query_ids that have this field_name / class_name as a vector
/query/{class_name}/{query_id}.json => meta-data about the query {processor, vectors}
/query/{class_name}/{query_id}/{record_initial}.json => a-z0-9 indexes each containing a list of query matching record_ids that start with that character

/feed/{class_name}/{query_id}/{connection_id}.json => each connection that is interested in this query has a feed configuration object stored here
/subscription/{class_name}/{record_id}/{connection_id}.json => each connection that is interested in this record has a subscription configuration object stored here


---


CONNECTION PATHS

/connection/{connection_id}.json => metadata about this connection
/connection/{connection_id}/aliases.json => a map of connection paths with overriding aliases, e.g. to allow to more friendly URL paths for given queries, record or views
/connection/{connection_id}/record/{class_name}/{record_id}.json => the masked record data for this connection
/connection/{connection_id}/query/{class_name}/{query_id}.json => metadata about this query as curated to this connection
/connection/{connection_id}/query/{class_name}/{query_id}/{index_initial}.json => a-z0-9 indexes, but only containing records that are non-empty when masked for this connection
/connection/{connection_id}/feed/{class_name}/{query_id}/{sort_field}/{min-index}-{max-index}.{view_id} => query data as rendered by the given view
/connection/{connection_id}/subscription/{class_name}/{record_id}.{view_id} => record data as rendered by the given view 
/connection/{connection_id}/subscription/{class_name}/{record_id}/{record_field}.{view_id} => record field data as rendered by the given view


---


LIFECYCLE

* schema.py writes schema data to all system paths under /schema on-demand by an administrator

* write.py writes a record to /record/{class_name}/{record_id}.json, which also generates a version record at /version/{class_name}/{record_id}/{version_id}.json
    * react-version.py:
        * uses /vector/{class_name}/{field_name}.json to find affected queries 
            * calls query-record.py with the full record for each affected query to update the relevant indexes in /query/{class_name}/{query_id}/{record_initial}.json
        * uses 


-----



** 2 -- /_/connection/{connection_id}.json 
     - PUT/POST/PATCH - accepts an object containing authentication data, writes object {mask: {}} , mask property is generated by the authentication processor
     - DELETE - immediately removes the connection object 
     ** => react-connection.py


** 4+ -- /_/connection/{connection_id}/asset/{asset_path} (path[2] == 'asset' | 'static')
     - PUT/POST/PATCH - directly writes object verbatum to /_/asset/{asset_path}, uses given contentType
        - PUT only if not already exists
        - POST if exists or not exists
        - PATCH - only if already exists
     - DELETE - immediately removes the asset at /asset/{asset_path}.json


** 6 -- /_/connection/{connection_id}/record/{class_name}/{record_id}/{record_field}.json
    - PUT/POST/PATCH - updates /_/record/{class_name}/{record_id}[record_field]
        - PATCH only if record already exists
    - DELETE - removes this field


** 5 -- /_/connection/{connection_id}/query/{class_name}/{query_id}.json 
    - PUT/POST/PATCH - accepts an object {processor, options, vectors}, overlays onto /_/query/{class_name}/{query_id}.json
        - PUT - replaces completely
        - POST - overlays or creates
        - PATCH overlays only if already exists
    - DELETE - removes /_/query/{class_name}/{query_id}.json
    - GET - return {processor, options, vectors, count}
    ** -> react-query.py


** 5 -- /_/connection/{connection_id}/record/{class_name}/{record_id}.json
    - PUT/POST/PATCH - overlays /_/record/{class_name}/{record_id}.json, writes changed fields to /_/version/{class_name}/{record_id}/{version_id}.json
        - PUT - replaces completely
        - POST - overlays or creates
        - PATCH overlays only if already exists
    - DELETE - removes this record
    - GET - return the record formatted into the chosen view, masked by the connection mask
    ** -> react-version.py


** 5 -- /_/connection/{connection_id}/view/{class_name}/{view_id}.json
    - PUT/POST/PATCH - accepts an object {processor, options, assets}, overlays onto /_/view/{class_name}/{view_id}.json
        - PUT - replaces completely
        - POST - overlays or creates
        - PATCH overlays only if already exists
    - DELETE - removes /_/view/{class_name}/{view_id}.json
    - GET - return {processor, options, assets}
    ** calculate all compiled views using this view


** 5 -- /_/connection/{connection_id}/feed/{class_name}/{query_id|record_id}.json
    - PUT/POST/PATCH - {expires, max, next, last, count, view}, connection_id is written to /_/feed/{class_name}/{query_id|record_id}/{connection_id}.json (which is a {})
    - GET - {feed connection options object} if connection_id present at /_/feed/{class_name}/{query_id|record_id}/{connection_id}.json
    - DELETE - connection_id is removed from /_/feed/{class_name}/{query_id|record_id}/{connection_id}.json
    ** calculate affected views

