SYSTEM PATHS

/schema/classes.json
/schema/classes/{class_name}.json
/schema/properties.json
/schema/properties/{property}.json
/schema/datatypes.json
/schema/datatypes/{datatype}.json

/record/{class_name}/{record_id}.json => canonical record
/version/{class_name}/{record_id}/{version_id}.json => list of record fields updated for each version

/vector/{class_name}/{field_name}.json => list of query_ids that have this field_name / class_name as a vector
/query/{class_name}/{query_id}.json => meta-data about the query {processor, vectors}
/query/{class_name}/{query_id}/{record_initial}.json => a-z0-9 indexes each containing a list of query matching record_ids that start with that character

/feed/{class_name}/{query_id}/{connection_id}.json => each connection that is interested in this query has a feed configuration object stored here
/subscription/{class_name}/{record_id}/{connection_id}.json => each connection that is interested in this record has a subscription configuration object stored here

/view/{view_id}.json

/system/{scope}/{module}.json
/system/authentication/{module}.json
/system/extension/{module}.json

/trash/record/{record_id}.json

---


CONNECTION PATHS

/connection/{connection_id}.json => metadata about this connection
/connection/{connection_id}/record/{class_name}/{record_id}.json => the masked record data for this connection
/connection/{connection_id}/query/{class_name}/{query_id}.json => metadata about this query as curated to this connection
/connection/{connection_id}/query/{class_name}/{query_id}/{index_initial}.json => a-z0-9 indexes, but only containing records that are non-empty when masked for this connection
/connection/{connection_id}/feed/{class_name}/{query_id}/{sort_field}/{sort_direction}/{min-index}-{max-index}.{view_id} => query data as rendered by the given view
/connection/{connection_id}/subscription/{class_name}/{record_id}.{view_id} => record data as rendered by the given view 
/connection/{connection_id}/subscription/{class_name}/{record_id}/{record_field}.{view_id} => record field data as rendered by the given view
/connection/{connection_id}/system/{scope}/{module}.json

---


CORE FUNCTIONS

* initialise (tested)
    - run once by an administrator to install the system into a AWS S3 Bucket
    - take a set of parameters {"system_user_key": "-----", "system_user_name": "system"}
    - return True when complete

* schema (tested)
    - triggered on-demand by an administrator
    - updates schema data to all system paths under /schema

* clean.py (ready for testing)
    - triggered on-demand by an administrator
    - schema-enforce: runs validation over every record in the system and moves them to /trash/record/{record_id}.json if found invalid
    - delete-marker-tidy: removes version objects related to deleted records


* write.py (testing in progress...)
    - triggered as an endpoint for a CDN or API originated PUT / PATCH / POST / DELETE request, or a websocket $put/$post/$patch/$delete message
    - writes/deletes a connection configuration to ~connection/{connection_id}.json OR (tested)
    - writes/deletes a view configuration to /view/{view_id}.json via /connection/{connection_id}/view/{view_id}.json OR
    - writes/deletes an private asset to ~asset/{assetpath} via ~connection/{connection_id}/asset/{path} OR
    - writes/deletes an static asset to {path} via ~connection/{connection_id}/static/{path} OR
    - writes/deletes a query configuration to /query/{class_name}/{query_id}.json via /connection/{connection_id}/query/{class_name}/{query_id}.json  OR (tested)
    - writes/deletes a feed configuration to /feed/{class_name}/{query_id}/{connection_id}.json via /connection/{connection_id}/feed/{class_name}/{query_id}.json OR 
    - writes/deletes a subscription configuration to /subscription/{class_name}/{record_id}/{connection_id}.json via /connection/{connection_id}/subscription/{class_name}/{record_id}.json OR 
    - writes/deletes a system module configuration to /system/{scope}/{module}.json via /connection/{connection_id}/system/{scope}/{module}.json OR
    - writes a record to /record/{class_name}/{record_id}.json via /connection/{connection_id}/record/{class_name}/{record_id}.json OR (tested)
    - writes a record field to /record/{class_name}/{record_id}[field_name].json via /connection/{connection_id}/record/{class_name}/{record_id}/{field_name}.json
    - generates a version record at /version/{class_name}/{record_id}/{version_id}.json

    
* react-connection.py (ready for testing)
    - triggered by writes at /connection/{connection_id}.json
    - deletes all objects under /connection/{connection_id}/

* react-query.py (testing)
    - triggered by writes at /query/{class_name}/{query_id}.json
    - for each field in /vector/{class_name}/, remove the query_id if the field name is not in query->vector
    - for each query->vector, ensure that the query_id is present in /vector/{class_name}.json
    - trigger query-record.py for every record in /record/{class_name}

* react-feed.py (ready for testing)
    - triggered by writes at /feed/{class_name}/{query_id}/{connection_id}.json
    - trigger view.py for each view configuration in feed->view

* react-subscription.py (ready for testing)
    - triggered by writes at /subscription/{class_name}/{record_id}/{connection_id}.json
    - trigger view.py for each view configuration in subscription->view

* react-view.py (ready for testing)
    - triggered by writes at /view/{view_id}.json
    - use /subscription/{class_name}/{record_id}/{connection_id}.json to get all affected connection subscriptions
    - trigger view.py for each view configuration in each affected subscription->view of each affected connection
    - use /feed/{class_name}/{query_id}/{connection_id}.json to get all affected connection feeds
    - trigger view.py for each view configuration in each affected feed->view of each affected connection

* react-version.py (ready for testing)
    - triggered by new objects at /version/{class_name}/{record_id}/{version_id}.json
    - uses /vector/{class_name}/{field_name}.json to find affected queries 
    - triggers query.py with the full record for each affected query to update the relevant indexes in /query/{class_name}/{query_id}/{record_initial}.json
    - uses /subscription/{class_name}/{record_id}/{connection_id}.json to find affected connections
    - triggers mask.py for each affected connection

* react-index.py (ready for testing)
    - triggered by new/updated object at /query/{class_name}/{query_id}/{record_initial}.json
    - uses /feed/{class_name}/{query_id}/{connection_id}.json to find affected connections
    - triggers mask.py for each record_id in the index that doesn't already exist in the /connection/{connection_id}/record/{class_name}/{record_id}.json
    
* react-connection-record.py (ready for testing)
    - triggered by new/updated/deleted objects in /connection/{connection_id}/record/{class_name}/{record_id}.json
    - removes the relevant record_id from /connection/{connection_id}/query/{class_name}/{query_id}/{index_initial}.json if the masked value is empty
    - uses /subscription/{class_name}/{record_id}/{connection_id}.json to find affected views for this connection and record
    - trigger view.py for each affected subscription view 
    
* react-connection-index.py (ready for testing)
    - triggered by new/updated/deleted /connection/{connection_id}/query/{class_name}/{query_id}/{index_initial}.json
    - uses /feed/{class_name}/{query_id}/{connection_id}.json to find affected views for this connection and query
    - trigger view.py for each affected feed view


* validate (tested)
    - triggered by clean.py, write.py
    - validate the given record according to its datatype
        
* authenticate (tested)
    - triggered by write.py
    - takes care of authentication sub-processes
    - returns a connection object with (at least) a 'mask' property, which is overlaid onto _/connection/{connection_id}.json

* query (tested)
    - triggered by react-query.py, react-version.py
    - executes the given query using the given record, returning True if matching

* mask.py (tested)
    - triggered by write.py, react-version.py, react-index.py, react-connection-record.py, react-connection-index.py
    - given a connection_id and a record, writes the masked version of the record to /connection/{connection_id}/record/{class_name}/{record_id}.json
    
* view.py (ready for testing)
    - triggered by react-feed.py, react-subscription.py, react-view.py, react-connection-record.py, react-connection-index.py
    - runs the given view with the given masked record/query results and writes the result to the relevant view path(s)



EXTENSION FUNCTIONS

* authentication/sudo
    - a sudo authenticator

* query/books
    - a query processor for filtering book records

-----

ENTITY TYPES

connection => {mask=[]}

view => {processor='', ?options={}, ?assets={alias: assetpath}, ?content_type='', ?suffix=''}

query => {processor='', ?options={}, vector=[], ?count=0}

feed => {view=[{view_id='', ?field_name, ?expires=0, ?sort_field='', ?sort_direction='', ?min_index=0, ?max_index=0}]}

subscription => {view=[{view_id='', field_name='', ?expires=0}]}

system => {}

record => {@type, @id,  ...as per various schemas conforming to it's own @type... }


-----


SYSTEM CONFIGURATION FORMAT

/system/{scope}/{module}.json  => /{entity_type}/{class_name}/{entity_id}.json



e.g. 

/system/authentication/password.json => {"processor": "lambda function name", "options": {free form map of options passed to function}, "priority": 0}
/system/authentication/key.json => {"processor": "lambda function name", "options": {free form map of options passed to function}, "priority": 1}



----- 

MASK FORMAT

{"*": "*"}  =>    all permissions 

{"record": "*"}  => can do anything with any record

record mask = {"record": {"GET": "*"}}   => can GET (view) any record

{"record": {"GET": {"Book": "*"}}}   => can GET (view) any Book record

{"record": {"GET": {"Book": {"mask-function-id-1": {"options1": 1}, "mask-function-2": {"option2": 234}}}}}  => the allowfields of mask-function-1 and mask-function-2 will be used to determine which fields 
of Book record the connection can GET (view)
 

{"asset": {"GET": {"file.png": "*"} } }  => can view _/asset/file.png

{"asset": {"GET": {"profiles/": "*"} } }   => can view any file under the _/profiles/ path

{"asset": {"GET": {"profiles/": {"testuser.png": "*"} } } }  => cam view the file _/profiles/testuser.png

{"asset": {"GET": {"profiles/": {"testuser.png": {"mask-function-id": {"option1": 123}}}}}}  => if the result of mask-function-id is True, then can view _/profiles/testuser.png
